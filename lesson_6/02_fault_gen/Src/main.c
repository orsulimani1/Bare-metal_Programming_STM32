/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <NVIC_registers.h>
#include <stdint.h>
#include <stdio.h>

/* Fault status structure to pass information between handlers */
typedef struct {
    uint32_t fault_type;
    uint32_t fault_address;
    uint32_t stacked_r0;
    uint32_t stacked_r1;
    uint32_t stacked_r2;
    uint32_t stacked_r3;
    uint32_t stacked_r12;
    uint32_t stacked_lr;
    uint32_t stacked_pc;
    uint32_t stacked_psr;
    uint32_t cfsr;           /* Configurable Fault Status Register */
    uint32_t hfsr;           /* Hard Fault Status Register */
    uint32_t dfsr;           /* Debug Fault Status Register */
    uint32_t mmfar;          /* MemManage Fault Address Register */
    uint32_t bfar;           /* Bus Fault Address Register */
    uint32_t afsr;           /* Auxiliary Fault Status Register */
} fault_info_t;

/* Global variable to hold fault information */
volatile fault_info_t g_fault_info;

/* Fault type constants */
#define FAULT_TYPE_HARD       1
#define FAULT_TYPE_MEMMANAGE  2
#define FAULT_TYPE_BUS        3
#define FAULT_TYPE_USAGE      4

/* Helper function to analyze Configurable Fault Status Register */
void analyze_cfsr(uint32_t cfsr) {
    printf("CFSR Analysis (0x%08lX):\n", cfsr);

    /* Memory Management Fault Status (MMFSR) - byte 0 */
    if (cfsr & 0xFF) {
        printf("Memory Management Fault:\n");
        if (cfsr & (1 << 0)) printf("  * Instruction access violation\n");
        if (cfsr & (1 << 1)) printf("  * Data access violation\n");
        if (cfsr & (1 << 2)) printf("  * Exception during unstacking\n");
        if (cfsr & (1 << 3)) printf("  * Exception during stacking\n");
        if (cfsr & (1 << 4)) printf("  * Lazy floating-point state preservation\n");
        if (cfsr & (1 << 7)) printf("  * MMFAR holds valid address\n");
    }

    /* Bus Fault Status (BFSR) - byte 1 */
    if ((cfsr >> 8) & 0xFF) {
        printf("Bus Fault:\n");
        if (cfsr & (1 << 8))  printf("  * Instruction bus error\n");
        if (cfsr & (1 << 9))  printf("  * Precise data bus error\n");
        if (cfsr & (1 << 10)) printf("  * Imprecise data bus error\n");
        if (cfsr & (1 << 11)) printf("  * Exception during unstacking\n");
        if (cfsr & (1 << 12)) printf("  * Exception during stacking\n");
        if (cfsr & (1 << 13)) printf("  * Lazy floating-point state preservation\n");
        if (cfsr & (1 << 15)) printf("  * BFAR holds valid address\n");
    }

    /* Usage Fault Status (UFSR) - byte 2-3 */
    if ((cfsr >> 16) & 0xFFFF) {
        printf("Usage Fault:\n");
        if (cfsr & (1 << 16)) printf("  * Undefined instruction\n");
        if (cfsr & (1 << 17)) printf("  * Invalid state (attempt to use floating-point when disabled)\n");
        if (cfsr & (1 << 18)) printf("  * Invalid PC load\n");
        if (cfsr & (1 << 19)) printf("  * No coprocessor\n");
        if (cfsr & (1 << 24)) printf("  * Unaligned access\n");
        if (cfsr & (1 << 25)) printf("  * Division by zero\n");
    }
}


/* Helper function to analyze Hard Fault Status Register */
void analyze_hfsr(uint32_t hfsr) {
    printf("HFSR Analysis (0x%08lX):\n", hfsr);

    if (hfsr & (1 << 1))  printf("  * Vector table read fault\n");
    if (hfsr & (1 << 30)) printf("  * Forced hard fault - escalated from other fault\n");
    if (hfsr & (1 << 31)) printf("  * Debug event - breakpoint with debug disabled\n");
}

/* Common fault handler used by all specific handlers */
void common_fault_handler(uint32_t fault_type, uint32_t *stack_frame) {
    /* Clear fault info structure */
    for (int i = 0; i < sizeof(fault_info_t)/sizeof(uint32_t); i++) {
        ((uint32_t*)&g_fault_info)[i] = 0;
    }

    /* Store fault information */
    g_fault_info.fault_type = fault_type;

    /* Store stacked registers from exception stack frame */
    g_fault_info.stacked_r0  = stack_frame[0];
    g_fault_info.stacked_r1  = stack_frame[1];
    g_fault_info.stacked_r2  = stack_frame[2];
    g_fault_info.stacked_r3  = stack_frame[3];
    g_fault_info.stacked_r12 = stack_frame[4];
    g_fault_info.stacked_lr  = stack_frame[5];
    g_fault_info.stacked_pc  = stack_frame[6];
    g_fault_info.stacked_psr = stack_frame[7];

    /* Store relevant fault status registers */
    g_fault_info.cfsr  = SCB_CFSR;   /* Configurable Fault Status Register */
    g_fault_info.hfsr  = SCB_HFSR;   /* Hard Fault Status Register */
    g_fault_info.dfsr  = SCB_DFSR;   /* Debug Fault Status Register */
    g_fault_info.mmfar = SCB_MMFAR;  /* MemManage Fault Address Register */
    g_fault_info.bfar  = SCB_BFAR;   /* Bus Fault Address Register */
    g_fault_info.afsr  = SCB_AFSR;   /* Auxiliary Fault Status Register */

    /* Based on fault type, determine the fault address */
    if (fault_type == FAULT_TYPE_MEMMANAGE && (g_fault_info.cfsr & 0x80)) {
        g_fault_info.fault_address = g_fault_info.mmfar;
    } else if (fault_type == FAULT_TYPE_BUS && (g_fault_info.cfsr & 0x8000)) {
        g_fault_info.fault_address = g_fault_info.bfar;
    } else {
        g_fault_info.fault_address = g_fault_info.stacked_pc;
    }

    /* Print fault information */
    printf("\n*** FAULT DETECTED ***\n");
    switch (fault_type) {
        case FAULT_TYPE_HARD:      printf("Type: Hard Fault\n"); break;
        case FAULT_TYPE_MEMMANAGE: printf("Type: MemManage Fault\n"); break;
        case FAULT_TYPE_BUS:       printf("Type: Bus Fault\n"); break;
        case FAULT_TYPE_USAGE:     printf("Type: Usage Fault\n"); break;
        default:                   printf("Type: Unknown Fault (%lu)\n", fault_type); break;
    }

    /* Print register values */
    printf("\nException Stack Frame:\n");
    printf("R0  = 0x%08lX\n", g_fault_info.stacked_r0);
    printf("R1  = 0x%08lX\n", g_fault_info.stacked_r1);
    printf("R2  = 0x%08lX\n", g_fault_info.stacked_r2);
    printf("R3  = 0x%08lX\n", g_fault_info.stacked_r3);
    printf("R12 = 0x%08lX\n", g_fault_info.stacked_r12);
    printf("LR  = 0x%08lX\n", g_fault_info.stacked_lr);
    printf("PC  = 0x%08lX\n", g_fault_info.stacked_pc);
    printf("PSR = 0x%08lX\n", g_fault_info.stacked_psr);

    printf("\nFault Address = 0x%08lX\n", g_fault_info.fault_address);

    /* Analyze fault status registers */
    analyze_cfsr(g_fault_info.cfsr);
    analyze_hfsr(g_fault_info.hfsr);

    /* Additional analysis could be added here */

    /* End with diagnostic message */
    printf("\nSystem halted due to fault.\n");

    /* Infinite loop to halt execution */
    while (1) {
        /* Dead loop */
        __asm volatile ("nop");
    }
}

/**
 * Handles any exception not covered by more specific handlers or when
 * those handlers are not enabled.
 */
void HardFault_Handler(void) {
    /* Use naked function and assembly to get correct stack frame pointer */
    __asm volatile
    (
        "TST    LR, #4              \n" /* Test bit 2 of link register to determine stack */
        "ITE    EQ                  \n" /* If equal (bit not set) */
        "MRSEQ  R0, MSP             \n" /* Use MSP as first argument */
        "MRSNE  R0, PSP             \n" /* Else use PSP as first argument */
        "MOV    R1, %0              \n" /* Move fault type to R1 */
        "B      Common_Handler      \n" /* Branch to common handler */
        :
        : "i" (FAULT_TYPE_HARD)
        : "r0", "r1"
    );
}

/**
 * Handles memory protection violations - executing from invalid regions,
 * accessing invalid address spaces, etc.
 */
void  MemManage_Handler(void) {
    /* Use naked function and assembly to get correct stack frame pointer */
    __asm volatile
    (
        "TST    LR, #4              \n" /* Test bit 2 of link register to determine stack */
        "ITE    EQ                  \n" /* If equal (bit not set) */
        "MRSEQ  R0, MSP             \n" /* Use MSP as first argument */
        "MRSNE  R0, PSP             \n" /* Else use PSP as first argument */
        "MOV    R1, %0              \n" /* Move fault type to R1 */
        "B      Common_Handler      \n" /* Branch to common handler */
        :
        : "i" (FAULT_TYPE_MEMMANAGE)
        : "r0", "r1"
    );
}

/**
 * Handles errors on the instruction or data buses - prefetch errors,
 * alignment faults, precise or imprecise data access errors
 */
void BusFault_Handler(void) {
    /* Use naked function and assembly to get correct stack frame pointer */
    __asm volatile
    (
        "TST    LR, #4              \n" /* Test bit 2 of link register to determine stack */
        "ITE    EQ                  \n" /* If equal (bit not set) */
        "MRSEQ  R0, MSP             \n" /* Use MSP as first argument */
        "MRSNE  R0, PSP             \n" /* Else use PSP as first argument */
        "MOV    R1, %0              \n" /* Move fault type to R1 */
        "B      Common_Handler      \n" /* Branch to common handler */
        :
        : "i" (FAULT_TYPE_BUS)
        : "r0", "r1"
    );
}

/**
 * Usage Fault Handler
 * Handles execution errors like undefined instructions, illegal unaligned access,
 * divide by zero, etc.
 */
void UsageFault_Handler(void) {
    /* Use naked function and assembly to get correct stack frame pointer */
    __asm volatile
    (
        "TST    LR, #4              \n" /* Test bit 2 of link register to determine stack */
        "ITE    EQ                  \n" /* If equal (bit not set) */
        "MRSEQ  R0, MSP             \n" /* Use MSP as first argument */
        "MRSNE  R0, PSP             \n" /* Else use PSP as first argument */
        "MOV    R1, %0              \n" /* Move fault type to R1 */
        "B      Common_Handler      \n" /* Branch to common handler */
        :
        : "i" (FAULT_TYPE_USAGE)
        : "r0", "r1"
    );
}

/**
 * Common handler C function that all fault handlers route to
 * Note: This function never returns
 */
void __attribute__((used)) Common_Handler(uint32_t *stack_frame, uint32_t fault_type) {
    common_fault_handler(fault_type, stack_frame);
}

/* Function to trigger a memory management fault */ // fix generate usage fault instead
void trigger_memmanage_fault(void) {
    printf("Attempting to trigger MemManage fault...\n");

    /* Define a no-access region by modifying MPU (Memory Protection Unit) */
    /* This is a simplified example - actual MPU setup would be more involved */

    /* For demonstration, we'll simply try to execute from a non-executable region */
    /* Create a function pointer to an invalid address in RAM */
    void (*bad_function)(void) = (void (*)(void))(SRAM_BASE + 0x100);

    /* Attempt to call through the invalid function pointer */
    bad_function();

    /* Should never reach here */
    printf("ERROR: Did not trigger expected MemManage fault\n");
}

/* Function to trigger a bus fault */
void trigger_bus_fault(void) {
    printf("Attempting to trigger Bus fault...\n");

    /* Access a non-existent memory address outside valid memory range */
    /* This address is outside the valid memory range for STM32F411VET6 */
    volatile uint32_t *bad_addr = (volatile uint32_t *)0xA0000000;

    /* Attempt to read from this address */
    volatile uint32_t dummy = *bad_addr;
    (void)dummy; /* Suppress unused variable warning */

    /* Should never reach here */
    printf("ERROR: Did not trigger expected Bus fault\n");
}

/* Function to trigger a usage fault */
void trigger_usage_fault(void) {
    printf("Attempting to trigger Usage fault...\n");

    /* Several ways to trigger usage fault */

    /* Option 1: Undefined instruction */
    printf("  Method 1: Undefined instruction\n");
    __asm volatile (".word 0xDEFE"); /* Insert undefined instruction */

    /* Should never reach here */
    printf("ERROR: Did not trigger expected Usage fault\n");

    /* Option 2: Unaligned memory access (if enabled in CCR) */
    printf("  Method 2: Unaligned access\n");
    volatile uint32_t *aligned_ptr = (volatile uint32_t *)0x20000000;
    volatile uint32_t *unaligned_ptr = (volatile uint32_t *)((uint8_t*)aligned_ptr + 1);
    *unaligned_ptr = 0; /* Unaligned store */

    /* Option 3: Division by zero (if enabled in CCR) */
    printf("  Method 3: Division by zero\n");
    volatile uint32_t zero = 0;
    volatile uint32_t result = 100 / zero;
    (void)result; /* Suppress unused variable warning */
}

/* Function to trigger a hard fault */
void trigger_hard_fault(void) {
    printf("Attempting to trigger Hard fault...\n");

    /* Method: Invalid vector table address */
    printf("  Method: Invalid vector table address\n");
    SCB_VTOR = 0x1FFFFFFF; /* Set VTOR to invalid address */

    /* Trigger an interrupt to use vector table */
    NVIC_TriggerInterrupt(EXTI0_IRQn);

    /* Should never reach here */
    printf("ERROR: Did not trigger expected Hard fault\n");
}

int main(void) {
    printf("Fault Handlers Example\n");
    printf("---------------------\n");

    /* Enable fault handlers */
    SCB_SHCSR |= (SCB_SHCSR_MEMFAULTENA_Msk |
                 SCB_SHCSR_BUSFAULTENA_Msk |
                 SCB_SHCSR_USGFAULTENA_Msk);

    printf("Fault handlers enabled:\n");
    printf("- Memory Management Fault\n");
    printf("- Bus Fault\n");
    printf("- Usage Fault\n");

    /* Optional: Configure additional fault behavior */
    /* Enable trapping of divide-by-zero and unaligned access */
    SCB_CCR |= (1 << 4) | (1 << 3);

    /* Ask user which fault to trigger */
    printf("\nSelect fault to trigger (modify for your input method):\n");
    printf("1 - Memory Management Fault\n");
    printf("2 - Bus Fault\n");
    printf("3 - Usage Fault\n");
    printf("4 - Hard Fault\n");

    /* For demonstration, we'll directly call one of the fault triggers */
    /* In real code, you might want to get user input here */
    int choice = 1; /* Modify this for testing different faults */

    /* Delay before triggering fault */
    for(volatile int i = 0; i < 1000000; i++) { }

    /* Trigger selected fault */
    switch(choice) {
        case 1: trigger_memmanage_fault(); break;
        case 2: trigger_bus_fault(); break;
        case 3: trigger_usage_fault(); break;
        case 4: trigger_hard_fault(); break;
        default: printf("Invalid selection\n"); break;
    }

    /* Should never reach here if fault was triggered */
    printf("No fault triggered or fault handled and returned\n");
	for(;;);
}
