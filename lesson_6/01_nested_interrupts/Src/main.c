/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <NVIC_registers.h>
#include <stdint.h>
#include <stdio.h>

#define PRIMARY_IRQ    38  /* USART2 IRQ number */
#define NESTED_IRQ     37  /* USART1 IRQ number */


/* Interrupt state tracking */
volatile uint32_t g_primary_entry_count = 0;
volatile uint32_t g_primary_exit_count = 0;
volatile uint32_t g_nested_entry_count = 0;
volatile uint32_t g_nested_exit_count = 0;

/* EXC_RETURN values at different points */
volatile uint32_t g_primary_exc_return = 0;
volatile uint32_t g_nested_exc_return = 0;
volatile uint32_t g_primary_exc_return_after_nested = 0;

void print_stack_frame(const char* label, volatile uint32_t *stack_frame) {
    printf("===== %s =====\n", label);
    printf("R0   = 0x%08lX\n", stack_frame[0]);  /* R0 is at offset 0 */
    printf("R1   = 0x%08lX\n", stack_frame[1]);  /* R1 is at offset 1 */
    printf("R2   = 0x%08lX\n", stack_frame[2]);  /* R2 is at offset 2 */
    printf("R3   = 0x%08lX\n", stack_frame[3]);  /* R3 is at offset 3 */
    printf("R12  = 0x%08lX\n", stack_frame[4]);  /* R12 is at offset 4 */
    printf("LR   = 0x%08lX\n", stack_frame[5]);  /* LR is at offset 5 */
    printf("PC   = 0x%08lX\n", stack_frame[6]);  /* PC is at offset 6 */
    printf("xPSR = 0x%08lX\n", stack_frame[7]);  /* xPSR is at offset 7 */
    printf("===============================\n");
}


/**
 * Nested Interrupt Handler
 */
void USART1_IRQHandler(void) {
    /* Track entry */
    g_nested_entry_count++;

    /* Capture EXC_RETURN value at entry */
    g_nested_exc_return = read_exc_return();

    /* Get pointer to stacked registers */
    uint32_t *stack_frame = (uint32_t *)__get_MSP();  /* Always MSP in handler mode */

    printf("\n** ENTERED NESTED INTERRUPT HANDLER **\n");
    printf("NESTED EXC_RETURN: 0x%08lX (%s)\n",
           g_nested_exc_return, decode_exc_return(g_nested_exc_return));

    /* Print stack frame */
    print_stack_frame("NESTED INTERRUPT STACK FRAME", stack_frame);

    /* Show interrupt nesting state */
    printf("Interrupt Nesting State:\n");
    printf("  Primary Handler: Entry(%lu) Exit(%lu)\n",
           g_primary_entry_count, g_primary_exit_count);
    printf("  Nested Handler:  Entry(%lu) Exit(%lu)\n",
           g_nested_entry_count, g_nested_exit_count);

    /* Show current stack pointer */
    printf("MSP during nested handler: 0x%08lX\n", (uint32_t)stack_frame);

    /* Clear pending flag */
    NVIC_ClearPendingIRQ(NESTED_IRQ);

    /* Track exit */
    g_nested_exit_count++;
    printf("** EXITING NESTED INTERRUPT HANDLER **\n");
    printf("Will return to Primary Handler using EXC_RETURN: 0x%08lX\n\n", g_nested_exc_return);
}


/**
 * Primary Interrupt Handler
 */
void USART2_IRQHandler(void) {
    /* Track entry */
    g_primary_entry_count++;

    /* Capture EXC_RETURN value at entry */
    g_primary_exc_return = read_exc_return();

    /* Get pointer to stacked registers */
    uint32_t *stack_frame = (uint32_t *)__get_MSP();  /* Always MSP in handler mode */

    printf("\n** ENTERED PRIMARY INTERRUPT HANDLER **\n");
    printf("PRIMARY EXC_RETURN: 0x%08lX (%s)\n",
           g_primary_exc_return, decode_exc_return(g_primary_exc_return));

    /* Print stack frame */
    print_stack_frame("PRIMARY INTERRUPT STACK FRAME", stack_frame);

    /* Show current stack pointer */
    printf("MSP during primary handler: 0x%08lX\n", (uint32_t)stack_frame);

    /* Show interrupt state before nested interrupt */
    printf("Interrupt State Before Nesting:\n");
    printf("  Primary Handler: Entry(%lu) Exit(%lu)\n",
           g_primary_entry_count, g_primary_exit_count);
    printf("  Nested Handler:  Entry(%lu) Exit(%lu)\n",
           g_nested_entry_count, g_nested_exit_count);

    printf("\nTriggering nested interrupt within primary handler...\n");

    /* Trigger the nested interrupt */
    NVIC_SetPendingIRQ(NESTED_IRQ);

    /* The processor will instantly jump to the nested handler if its priority is higher */

    /* When we return here, the nested handler has completed */

    /* Capture EXC_RETURN value after nested interrupt returns */
    g_primary_exc_return_after_nested = read_exc_return();

    printf("\nReturned to primary handler after nested interrupt\n");
    printf("PRIMARY EXC_RETURN (after nested): 0x%08lX (%s)\n",
           g_primary_exc_return_after_nested,
           decode_exc_return(g_primary_exc_return_after_nested));

    /* Show interrupt state after nested interrupt */
    printf("Interrupt State After Nesting:\n");
    printf("  Primary Handler: Entry(%lu) Exit(%lu)\n",
           g_primary_entry_count, g_primary_exit_count);
    printf("  Nested Handler:  Entry(%lu) Exit(%lu)\n",
           g_nested_entry_count, g_nested_exit_count);

    /* Compare EXC_RETURN values before and after nested interrupt */
    printf("\nEXC_RETURN comparison:\n");
    printf("  Before nested: 0x%08lX\n", g_primary_exc_return);
    printf("  After nested:  0x%08lX\n", g_primary_exc_return_after_nested);
    printf("  %s\n", (g_primary_exc_return == g_primary_exc_return_after_nested) ?
                     "EXC_RETURN preserved" : "EXC_RETURN changed");

    /* Clear the pending interrupt */
    NVIC_ClearPendingIRQ(PRIMARY_IRQ);

    /* Track exit */
    g_primary_exit_count++;
    printf("** EXITING PRIMARY INTERRUPT HANDLER **\n");
    printf("Will return to Thread Mode using EXC_RETURN: 0x%08lX\n\n", g_primary_exc_return);
}

/* Setup and trigger the nested interrupt demo */
void trigger_nested_interrupt_demo(void) {
    printf("\n=== STARTING NESTED INTERRUPT DEMO ===\n");
    printf("Initial stack pointer (MSP): 0x%08lX\n", __get_MSP());

    /* Trigger the primary interrupt */
    printf("\nTriggering primary interrupt...\n");
    NVIC_SetPendingIRQ(PRIMARY_IRQ);

    /* After returning from all interrupts */
    printf("\n=== RETURNED TO MAIN FUNCTION ===\n");
    printf("Final interrupt counts:\n");
    printf("  Primary Handler: Entry(%lu) Exit(%lu)\n",
           g_primary_entry_count, g_primary_exit_count);
    printf("  Nested Handler:  Entry(%lu) Exit(%lu)\n",
           g_nested_entry_count, g_nested_exit_count);
    printf("MSP after interrupts: 0x%08lX\n", __get_MSP());

    printf("\nEXC_RETURN values captured:\n");
    printf("  Primary Handler: 0x%08lX (%s)\n",
           g_primary_exc_return, decode_exc_return(g_primary_exc_return));
    printf("  Nested Handler:  0x%08lX (%s)\n",
           g_nested_exc_return, decode_exc_return(g_nested_exc_return));
    printf("  Primary after nested: 0x%08lX (%s)\n",
           g_primary_exc_return_after_nested,
           decode_exc_return(g_primary_exc_return_after_nested));
}

int main(void) {
    printf("\n--- Nested Interrupt with EXC_RETURN Demo ---\n");

    /* Configure NVIC for our interrupts */

    /* Configure priorities - LOWER number means HIGHER priority */
    NVIC_SetPriority(PRIMARY_IRQ, 3); /* Lower priority (higher number) */
    NVIC_SetPriority(NESTED_IRQ, 1);  /* Higher priority (lower number) */

    /* Enable both interrupts */
    NVIC_EnableIRQ(PRIMARY_IRQ);
    NVIC_EnableIRQ(NESTED_IRQ);

    /* Print initial processor state */
    printf("Initial processor state:\n");
    printf("  CPU Mode: Thread Mode\n");
    printf("  Active stack: %s\n", (__get_CONTROL() & 2) ? "PSP" : "MSP");
    printf("  Priority grouping: 3 bits preemption\n");
    printf("  PRIMARY_IRQ priority: 3\n");
    printf("  NESTED_IRQ priority: 1 (higher)\n\n");

    /* Trigger the demo */
    trigger_nested_interrupt_demo();

    /* Loop forever */
    printf("\nDemo complete. Entering infinite loop.\n");
    for(;;);

    return 0;
}
