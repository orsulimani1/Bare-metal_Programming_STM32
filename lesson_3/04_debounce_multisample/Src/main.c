/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include "stm32f411.h"

// Define button states
#define BUTTON_RELEASED 0
#define BUTTON_PRESSED 1

// Define GPIOA pointer
GPIO_TypeDef *GPIOA = (GPIO_TypeDef *)GPIOA_BASE_ADDR;

// Simple delay function
int Delay(int count) {
    for (int var = 0; var < count*1000; ++var);
    return 1;
}

// Enable GPIOA clock
void setup_gpio_a_clock() {
    uint32_t *p_clk_ctrl_reg = (uint32_t *)(RCC_AHB1ENR);
    // Enable GPIOA clock
    *p_clk_ctrl_reg |= (0x1 << 0);
}


// Button debouncing using multiple samples approach
uint8_t read_button_multiple_samples(void) {
    static uint8_t button_state = BUTTON_RELEASED;
    static uint8_t counter = 0;
    const uint8_t debounce_count = 10;  // Number of consecutive samples

    // Read raw button state - using the bitfield access like in first program
    uint8_t raw_state = (GPIOA->IDR.IDR0 & BUTTON_PRESSED) ? 1 : 0;

    // Reset counter if state changes
    if (raw_state != button_state) {
        if (counter > 0) {
            counter--;
        }
    } else {
        // Increment counter for consistent readings
        if (counter < debounce_count) {
            counter++;
        }

        // Update state after sufficient consistent readings
        if (counter >= debounce_count) {
            button_state = raw_state;
        }
    }

    return button_state;
}

int main(void)
{
	 setup_gpio_a_clock();
	GPIOA->MODER.MODER0 = 0;  // Set pin 0 as input

    // Main loop - same as in first program
    do {
        read_button_multiple_samples();
    } while(Delay(200));
	for(;;);
}
