/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include "stm32f411.h"
#define BUTTON_RELEASED 0
#define BUTTON_PRESSED 1



void setup_gpio_a_clock(){
	uint32_t *p_clk_ctrl_reg = (uint32_t *)(RCC_AHB1ENR);
	//	get the RRC value
	*p_clk_ctrl_reg |= (0x1 << 0);
}

int Delay(int count){
	for (volatile int var = 0;  var < count*1000; ++ var);
	return 1;
}

GPIO_TypeDef *GPIOA = (GPIO_TypeDef *)GPIOA_BASE_ADDR;

uint8_t read_button_with_delay(void) {
    static uint8_t button_state = BUTTON_RELEASED;

    // Read the raw button state
    uint8_t raw_state = (GPIOA->IDR.IDR0 & BUTTON_PRESSED) ? 1 : 0;

    // If state changed
    if (raw_state != button_state) {
        // Simple delay-based debounce
        Delay(20);  // Wait 20ms

        // Read again after delay
        raw_state = (GPIOA->IDR.IDR0 & BUTTON_PRESSED) ? 1 : 0;

        // Update button state
        button_state = raw_state;
    }

    return button_state;
}

int main(void)
{
	setup_gpio_a_clock();
	GPIOA->MODER.MODER0 = 0; // input mode
	do{
		read_button_with_delay();
	} while(Delay(200));
	for(;;);
}
